---
title: "å®Ÿéš›ã«ç°¡å˜ãªã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’ä½œã£ã¦ã¿ã‚ˆã†ï¼ˆãƒ¯ãƒ¼ã‚¯ã‚·ãƒ§ãƒƒãƒ—ï¼‰"
---

# GitHubè§£æã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆé–‹ç™ºãƒ¯ãƒ¼ã‚¯ã‚·ãƒ§ãƒƒãƒ—ã¸ã‚ˆã†ã“ãï¼ğŸš€

å‰ç« ã§ç„¡äº‹ã«Mastraã®ç’°å¢ƒæ§‹ç¯‰ã¨ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ§‹é€ ã®æŠŠæ¡ãŒã§ãã¾ã—ãŸã­ã€‚ç´ æ™´ã‚‰ã—ã„ï¼ã„ã‚ˆã„ã‚ˆã“ã“ã‹ã‚‰ãŒæœ¬ç•ªã€é­”æ³•ã®ã‚ˆã†ãªä½“é¨“ã®å§‹ã¾ã‚Šã§ã™ï¼ã“ã®ç« ã§ã¯ã€ã‚ãªãŸã‚‚ç°¡å˜ã«ä½œã‚Œã‚‹å®Ÿç”¨çš„ãªã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’ä¸€ç·’ã«é–‹ç™ºã—ãªãŒã‚‰ã€Mastraã®çœŸã®åŠ›ã‚’ä½“æ„Ÿã—ã¦ã„ãã¾ã—ã‚‡ã†ã€‚å¿ƒé…ã‚ã‚Šã¾ã›ã‚“ã€ä¸€æ­©ä¸€æ­©é€²ã‚ã¦ã„ãã®ã§ã€åˆå¿ƒè€…ã®æ–¹ã§ã‚‚å¤§ä¸ˆå¤«ã§ã™ï¼

ä»Šå›ç§ãŸã¡ãŒæŒ‘æˆ¦ã™ã‚‹ã®ã¯ã€GitHubãƒªãƒã‚¸ãƒˆãƒªã‚’è§£æã—ã¦ã€ãªã‚“ã¨Cursor Rulesã‚’è‡ªå‹•ã§ä½œã£ã¦ãã‚Œã‚‹ä¾¿åˆ©ãªã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã§ã™ã€‚é›£ã—ãã†ï¼Ÿã„ã„ãˆã€ãã‚“ãªã“ã¨ã‚ã‚Šã¾ã›ã‚“ï¼ã“ã®å†’é™ºã‚’ä¸€ç·’ã«æ¥½ã—ã¿ãªãŒã‚‰ã€ã‚µã‚¯ãƒƒã¨ä½œã‚Šä¸Šã’ã¦ã„ãã¾ã—ã‚‡ã†ã€‚ã‚ãªãŸã‚‚é©šãã»ã©ã‚·ãƒ³ãƒ—ãƒ«ã«å®Ÿè£…ã§ãã¾ã™ã‚ˆï¼

## GitHub Cursor Rulesç”Ÿæˆã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®æ¦‚è¦ âœ¨

ã¾ãšã¯ã€Œã“ã®ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã£ã¦ä½•ãŒã§ãã‚‹ã®ï¼Ÿã€ã¨ã„ã†ç–‘å•ã‚’ã‚¹ãƒƒã‚­ãƒªè§£æ¶ˆã—ã¾ã—ã‚‡ã†ï¼

### ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®ç›®çš„ã¨æ©Ÿèƒ½

ã“ã®ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¯ã€ã‚ãªãŸã®ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ä½“é¨“ã‚’åŠ‡çš„ã«å‘ä¸Šã•ã›ã‚‹é­”æ³•ã®æ–ã®ã‚ˆã†ãªå­˜åœ¨ã§ã™ï¼š

1. GitHubã®ãƒªãƒã‚¸ãƒˆãƒªã‚’**ãƒ¯ãƒ³ã‚¯ãƒªãƒƒã‚¯ã§**è‡ªå‹•ã‚¯ãƒ­ãƒ¼ãƒ³
2. ãƒªãƒã‚¸ãƒˆãƒªå†…ã®ã‚³ãƒ¼ãƒ‰ã‚’**è³¢ãä¸å¯§ã«**è§£æ
3. ã‚³ãƒ¼ãƒ‰ã®ç‰¹å¾´ã‚„æ§‹é€ ã‚’**æ·±ãç†è§£**ã—ã¦ã€Cursorã¨ã„ã†AIã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆãŒä½¿ãˆã‚‹ç‰¹åˆ¥ãªãƒ«ãƒ¼ãƒ«ï¼ˆ.mdcï¼‰ã‚’**è‡ªå‹•ç”Ÿæˆ**

ã€Œãˆã€Cursor Rulesã£ã¦ä½•ï¼Ÿã€ã¨æ€ã£ãŸæ–¹ã‚‚å®‰å¿ƒã—ã¦ãã ã•ã„ï¼ç°¡å˜ã«è¨€ã†ã¨ã€Cursorã¨ã„ã†AIã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆãŒã‚ãªãŸã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’ã‚‚ã£ã¨æ·±ãç†è§£ã™ã‚‹ãŸã‚ã®ã€Œãƒãƒ¼ãƒˆã‚·ãƒ¼ãƒˆã€ã®ã‚ˆã†ãªã‚‚ã®ã§ã™ã€‚ã“ã‚ŒãŒã‚ã‚‹ã¨ã€CursorãŒãã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆç‰¹æœ‰ã®çŸ¥è­˜ã‚’æŒã£ãŸçŠ¶æ…‹ã§ã€ã‚ãªãŸã®ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’ã‚ˆã‚Šçš„ç¢ºã«ã‚µãƒãƒ¼ãƒˆã—ã¦ãã‚Œã‚‹ã‚“ã§ã™ã€‚ã™ã”ããªã„ã§ã™ã‹ï¼Ÿ

### ãªãœã“ã®ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒè¶…ä¾¿åˆ©ãªã®ã‹

ã“ã®ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’ä½œã‚‹ãƒ¡ãƒªãƒƒãƒˆã¯ã€æƒ³åƒä»¥ä¸Šã«ãƒ¯ã‚¯ãƒ¯ã‚¯ã™ã‚‹ã‚‚ã®ã°ã‹ã‚Šã§ã™ï¼š

1. **é€€å±ˆãªä½œæ¥­ãŒä¸€ç¬ã§å®Œäº†**: æ‰‹å‹•ã§ã‚³ãƒ¼ãƒ‰ãƒ™ãƒ¼ã‚¹ã‚’è§£æã—ã¦Cursor Rulesã‚’ä½œã‚‹ã£ã¦ã€æ­£ç›´ã‚ã¡ã‚ƒãã¡ã‚ƒå¤§å¤‰ã§ã™ã‚ˆã­ã€‚ã§ã‚‚å¿ƒé…ç„¡ç”¨ï¼ã“ã®ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒã‚ã‚Œã°ã€ã‚ãªãŸã¯ã‚³ãƒ¼ãƒ’ãƒ¼ã‚’ä¸€å£é£²ã‚€é–“ã«å®Œäº†ã—ã¾ã™ï¼â˜•

2. **AIã ã‹ã‚‰ã“ãè¦‹ã¤ã‘ã‚‹éš ã‚ŒãŸå®çŸ³**: äººé–“ã®ç›®ã§ã¯è¦‹è½ã¨ã—ãŒã¡ãªç´°ã‹ãªãƒ‘ã‚¿ãƒ¼ãƒ³ã‚„æ§‹é€ ã¾ã§AIãŒå¾¹åº•åˆ†æã€‚ãã®çµæœã€ãƒ€ã‚¤ãƒ¤ãƒ¢ãƒ³ãƒ‰ã®ã‚ˆã†ã«è¼ãé«˜å“è³ªãªCursor RulesãŒç”Ÿã¾ã‚Œã¾ã™ã€‚âœ¨

3. **æ¥½ã—ãå­¦ã¹ã‚‹Mastraã®é­”æ³•**: ã€Œå­¦ã¶ã€ã¨ã„ã†ã‚ˆã‚Šã€Œå†’é™ºã™ã‚‹ã€æ„Ÿè¦šã§ã€Mastraã®é‡è¦ãªæ©Ÿèƒ½ï¼ˆãƒ„ãƒ¼ãƒ«ã€ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ãªã©ï¼‰ãŒè‡ªç„¶ã¨èº«ã«ã¤ãã¾ã™ã€‚æ°—ã¥ã„ãŸã‚‰ã€ã‚ãªãŸã‚‚Mastraæ´»ç”¨ã®é”äººã«ï¼ğŸ§™â€â™‚ï¸

4. **ä»Šæ—¥ä½œã£ã¦ã€ä»Šæ—¥ã‹ã‚‰ä½¿ãˆã‚‹**: ä½œã£ãŸã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¯ç†è«–ä¸Šã®ç”£ç‰©ã§ã¯ãªãã€ã‚ãªãŸã®æ˜æ—¥ã®ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’å³åº§ã«æ”¯æ´ã™ã‚‹å®Ÿç”¨çš„ãªãƒ„ãƒ¼ãƒ«ã«ãªã‚Šã¾ã™ã€‚åŠ¹ç‡åŒ–ã®æ©æµã‚’ã™ãã«å®Ÿæ„Ÿã§ãã¾ã™ã‚ˆï¼ğŸ› ï¸

ã•ã‚ã€ã‚¨ã‚­ã‚µã‚¤ãƒ†ã‚£ãƒ³ã‚°ãªå†’é™ºã®å§‹ã¾ã‚Šã§ã™ï¼ä¸€ç·’ã«ã“ã®ç´ æ™´ã‚‰ã—ã„ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’ä½œã‚Šä¸Šã’ã¦ã„ãã¾ã—ã‚‡ã†ï¼ã‚ãªãŸã®ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ä½“é¨“ãŒåŠ‡çš„ã«å¤‰ã‚ã‚‹ç¬é–“ã‚’ã€ä»Šã‹ã‚‰ä¸€ç·’ã«æ¥½ã—ã¿ã¾ã—ã‚‡ã†ï¼ğŸš€

## ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’ä½œã‚‹: GitHubãƒ‡ãƒ¼ã‚¿å–å¾—ã¨è§£æ ğŸ”

ã•ã‚ã€ã„ã‚ˆã„ã‚ˆæœ¬æ ¼çš„ãªå®Ÿè£…ã«ç§»ã‚Šã¾ã™ï¼ãƒ¯ã‚¯ãƒ¯ã‚¯ã—ã¾ã™ã­ã€‚ã“ã“ã‹ã‚‰ã¯é­”æ³•ä½¿ã„ãŒå‘ªæ–‡ã‚’å”±ãˆã‚‹ã‚ˆã†ã«ã€GitHubãƒªãƒã‚¸ãƒˆãƒªã‚’è‡ªåœ¨ã«æ“ã‚‹ãƒ„ãƒ¼ãƒ«ã‚’ä¸€ç·’ã«ä½œã‚Šä¸Šã’ã¦ã„ãã¾ã—ã‚‡ã†ã€‚é›£ã—ãæ„Ÿã˜ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ãŒã€ä¸€ã¤ä¸€ã¤ã®ã‚¹ãƒ†ãƒƒãƒ—ã¯é©šãã»ã©ã‚·ãƒ³ãƒ—ãƒ«ãªã®ã§ã€å®‰å¿ƒã—ã¦å†’é™ºã‚’ç¶šã‘ã¦ãã ã•ã„ï¼

### å¿…è¦ãªãƒ„ãƒ¼ãƒ«ã®ä½œæˆ ğŸ› ï¸

ç§ãŸã¡ã®ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã«ã¯ã€ã„ãã¤ã‹ã®é­”æ³•ã®é“å…·ï¼ˆãƒ„ãƒ¼ãƒ«ï¼‰ãŒå¿…è¦ã§ã™ã€‚ã¾ã‚‹ã§ãƒ’ãƒ¼ãƒ­ãƒ¼ãŒç‰¹æ®Šè£…å‚™ã‚’èº«ã«ã¤ã‘ã‚‹ã‚ˆã†ã«ã€ã“ã‚Œã‹ã‚‰ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã«åŠ›ã‚’ä¸ãˆã¦ã„ãã¾ã—ã‚‡ã†ï¼Mastraã®ç´ æ™´ã‚‰ã—ã„ç‚¹ã¯ã€Zodã‚¹ã‚­ãƒ¼ãƒã‚’ä½¿ã£ã¦å…¥å‡ºåŠ›ã‚’ã‚­ãƒ¬ã‚¤ã«å‹ä»˜ã‘ã§ãã‚‹ã“ã¨ã§ã™ã€‚ã“ã‚Œã«ã‚ˆã£ã¦ã€ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒã€Œä½•ã‚’å—ã‘å–ã‚Šã€ä½•ã‚’è¿”ã™ã®ã‹ã€ãŒä¸€ç›®ç­ç„¶ã«ãªã‚Šã¾ã™ã‚ˆï¼

#### 1. GitHubãƒªãƒã‚¸ãƒˆãƒªã‚¯ãƒ­ãƒ¼ãƒ³ãƒ„ãƒ¼ãƒ« âœ¨

ã¾ãšã¯ç¬¬ä¸€ã®é­”æ³•ã®é“å…·ã€ã€Œã‚¯ãƒ­ãƒ¼ãƒ³ãƒ„ãƒ¼ãƒ«ã€ã‚’ä½œã‚Šã¾ã—ã‚‡ã†ï¼ã“ã®ãƒ„ãƒ¼ãƒ«ãŒã‚ã‚Œã°ã€GitHubã®æ˜Ÿï¼ˆãƒªãƒã‚¸ãƒˆãƒªï¼‰ã‚’ã‚ãªãŸã®ãƒ­ãƒ¼ã‚«ãƒ«å®‡å®™ã«å¬å–šã§ãã¾ã™ã€‚ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã‚’`src/mastra/tools/github-clone-tool.ts`ã¨ã—ã¦ä¿å­˜ã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚ã‚³ãƒ¼ãƒ‰ã¯å°‘ã—é•·ã„ã‚ˆã†ã«è¦‹ãˆã¾ã™ãŒã€å„éƒ¨åˆ†ã¯éå¸¸ã«ã‚·ãƒ³ãƒ—ãƒ«ãªå½¹å‰²ã‚’æŒã£ã¦ã„ã‚‹ã®ã§å¿ƒé…ã„ã‚Šã¾ã›ã‚“ï¼

```typescript
import { createTool } from "@mastra/core/tools";
import { exec } from "child_process";
import fs from "fs";
import path from "path";
import util from "util";
import { z } from "zod";

const execPromise = util.promisify(exec);

// å…¥åŠ›ã‚¹ã‚­ãƒ¼ãƒã®å®šç¾©
const inputSchema = z.object({
  repoUrl: z.string().describe("The GitHub repository URL to clone (e.g., https://github.com/username/repo)"),
  branch: z.string().optional().describe("Optional: The branch to clone")
});

// å‡ºåŠ›ã‚¹ã‚­ãƒ¼ãƒã®å®šç¾©
const outputSchema = z.object({
  success: z.boolean(),
  repoPath: z.string().optional(),
  message: z.string().optional(),
  error: z.string().optional()
});

export const githubCloneTool = createTool({
  id: "githubCloneTool",
  description: "Clone a GitHub repository to the local filesystem",
  inputSchema,
  outputSchema,
  execute: async ({ context }) => {
    const { repoUrl, branch } = context;
    
    try {
      // ä¸€æ™‚ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ä½œæˆ
      const tempDir = path.join(process.cwd(), "temp_repos");
      if (!fs.existsSync(tempDir)) {
        fs.mkdirSync(tempDir, { recursive: true });
      }

      // ãƒªãƒã‚¸ãƒˆãƒªåã‚’æŠ½å‡º
      const repoName = repoUrl.split("/").pop()?.replace(".git", "") || "repo";
      const repoPath = path.join(tempDir, repoName);

      // æ—¢ã«ã‚¯ãƒ­ãƒ¼ãƒ³æ¸ˆã¿ã‹ãƒã‚§ãƒƒã‚¯
      if (fs.existsSync(repoPath)) {
        return { 
          success: true, 
          repoPath, 
          message: `Repository already exists at ${repoPath}` 
        };
      }

      // ã‚¯ãƒ­ãƒ¼ãƒ³ã‚³ãƒãƒ³ãƒ‰ã‚’æ§‹ç¯‰
      let cloneCmd = `git clone ${repoUrl} ${repoPath}`;
      if (branch) {
        cloneCmd += ` --branch ${branch} --single-branch`;
      }

      // ãƒªãƒã‚¸ãƒˆãƒªã‚’ã‚¯ãƒ­ãƒ¼ãƒ³
      const { stdout, stderr } = await execPromise(cloneCmd);
      
      if (stderr && !stderr.includes("Cloning into")) {
        throw new Error(`Git clone error: ${stderr}`);
      }

      return { 
        success: true, 
        repoPath, 
        message: `Successfully cloned ${repoUrl} to ${repoPath}` 
      };
    } catch (error) {
      console.error("Failed to clone repository:", error);
      return { 
        success: false, 
        error: String(error) 
      };
    }
  }
});
```

ã“ã®ã‚³ãƒ¼ãƒ‰ã‚’è¦‹ã¦ã€Œã†ã‚ã€è¤‡é›‘ãã†...ã€ã¨æ€ã£ãŸæ–¹ã€å®‰å¿ƒã—ã¦ãã ã•ã„ï¼å®Ÿã¯ã¨ã¦ã‚‚ã‚·ãƒ³ãƒ—ãƒ«ãªæµã‚Œã«ãªã£ã¦ã„ã¾ã™ã€‚ã¾ãšå…¥åŠ›ã¨å‡ºåŠ›ã®ã‚¹ã‚­ãƒ¼ãƒã‚’å®šç¾©ã—ã¦ã€ã‚ã¨ã¯ã€Œãƒªãƒã‚¸ãƒˆãƒªURLã‚’ã‚‚ã‚‰ã£ãŸã‚‰â†’ä¸€æ™‚ãƒ•ã‚©ãƒ«ãƒ€ã‚’ä½œã£ã¦â†’ã‚¯ãƒ­ãƒ¼ãƒ³ã—ã¦â†’çµæœã‚’è¿”ã™ã€ã¨ã„ã†æ–™ç†ãƒ¬ã‚·ãƒ”ã®ã‚ˆã†ãªæ˜ç¢ºãªã‚¹ãƒ†ãƒƒãƒ—ã‚’å®Ÿè¡Œã—ã¦ã„ã‚‹ã ã‘ãªã‚“ã§ã™ã€‚ç´ æ•µã§ã™ã­ï¼âœ¨

#### 2. ãƒ•ã‚¡ã‚¤ãƒ«è§£æãƒ„ãƒ¼ãƒ« ğŸ”

æ¬¡ã«ä½œã‚‹ã®ã¯ã€ã€Œãƒ•ã‚¡ã‚¤ãƒ«è§£æãƒ„ãƒ¼ãƒ«ã€ã§ã™ã€‚ã“ã®ãƒ„ãƒ¼ãƒ«ã¯ã€ã‚¯ãƒ­ãƒ¼ãƒ³ã—ãŸãƒªãƒã‚¸ãƒˆãƒªã‚’æ¢æ¤œå®¶ã®ã‚ˆã†ã«éš…ã€…ã¾ã§èª¿æŸ»ã—ã€é‡è¦ãªæƒ…å ±ã‚’åé›†ã—ã¦ãã‚Œã‚‹è³¢ã„åŠ©æ‰‹ã§ã™ã€‚ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã‚’`src/mastra/tools/repo-analysis-tool.ts`ã¨ã—ã¦ä¿å­˜ã—ã¦ãã ã•ã„ã€‚

```typescript
import { createTool } from "@mastra/core/tools";
import fs from "fs";
import path from "path";
import { promisify } from "util";
import { z } from "zod";

const readdir = promisify(fs.readdir);
const stat = promisify(fs.stat);
const readFile = promisify(fs.readFile);

// é™¤å¤–ã™ã‚‹ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚„ãƒ•ã‚¡ã‚¤ãƒ«
const EXCLUDED_DIRS = [".git", "node_modules", "dist", "build", ".cache"];
const EXCLUDED_FILES = [".DS_Store", ".gitignore"];
const MAX_FILE_SIZE = 1024 * 1024; // 1MB

// å…¥åŠ›ã‚¹ã‚­ãƒ¼ãƒã®å®šç¾©
const inputSchema = z.object({
  repoPath: z.string().describe("The local path to the repository"),
  fileExtensions: z.array(z.string()).optional().describe("Optional: Array of file extensions to analyze (e.g. ['.js', '.ts'])"),
  maxFilesToAnalyze: z.number().optional().describe("Optional: Maximum number of files to analyze")
});

// ãƒ•ã‚¡ã‚¤ãƒ«æƒ…å ±ã‚¹ã‚­ãƒ¼ãƒ
const fileInfoSchema = z.object({
  path: z.string(),
  extension: z.string(),
  size: z.number(),
  lineCount: z.number(),
  content: z.string()
});

// ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹é€ ã‚¹ã‚­ãƒ¼ãƒ
const directoryStructureSchema = z.record(z.object({
  type: z.string(),
  children: z.array(z.object({
    name: z.string(),
    type: z.string(),
    extension: z.string().optional()
  })).optional()
}));

// ãƒªãƒã‚¸ãƒˆãƒªæƒ…å ±ã‚¹ã‚­ãƒ¼ãƒ
const repoInfoSchema = z.object({
  name: z.string(),
  path: z.string(),
  fileCount: z.number(),
  analyzedFiles: z.array(fileInfoSchema),
  fileTypes: z.record(z.number()),
  directoryStructure: directoryStructureSchema,
  summary: z.string()
});

// å‡ºåŠ›ã‚¹ã‚­ãƒ¼ãƒã®å®šç¾©
const outputSchema = z.object({
  success: z.boolean(),
  repoInfo: repoInfoSchema.optional(),
  error: z.string().optional()
});

export const repoAnalysisTool = createTool({
  id: "repoAnalysisTool",
  description: "Analyze files in a repository and extract code structure information",
  inputSchema,
  outputSchema,
  execute: async ({ context }) => {
    const { repoPath, fileExtensions, maxFilesToAnalyze = 100 } = context;
    
    try {
      // ãƒªãƒã‚¸ãƒˆãƒªã®åŸºæœ¬æƒ…å ±ã‚’åé›†
      const repoInfo = {
        name: path.basename(repoPath),
        path: repoPath,
        fileCount: 0,
        analyzedFiles: [],
        fileTypes: {},
        directoryStructure: {},
        summary: ""
      };

      // å†å¸°çš„ã«ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’èµ°æŸ»ã™ã‚‹é–¢æ•°
      const scanDirectory = async (dirPath, relativeDir = "") => {
        const entries = await readdir(dirPath, { withFileTypes: true });
        
        for (const entry of entries) {
          // é™¤å¤–ãƒ‘ã‚¹ã‚’ã‚¹ã‚­ãƒƒãƒ—
          if (EXCLUDED_DIRS.includes(entry.name) || EXCLUDED_FILES.includes(entry.name)) {
            continue;
          }

          const fullPath = path.join(dirPath, entry.name);
          const relativePath = path.join(relativeDir, entry.name);

          if (entry.isDirectory()) {
            // ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæƒ…å ±ã‚’ä¿å­˜
            repoInfo.directoryStructure[relativePath] = { type: "directory", children: [] };
            // å†å¸°çš„ã«å‡¦ç†
            await scanDirectory(fullPath, relativePath);
          } else if (entry.isFile()) {
            // ãƒ•ã‚¡ã‚¤ãƒ«æ•°ãŒåˆ¶é™ã«é”ã—ãŸã‚‰ã‚¹ã‚­ãƒƒãƒ—
            if (repoInfo.analyzedFiles.length >= maxFilesToAnalyze) {
              continue;
            }

            // ç‰¹å®šã®æ‹¡å¼µå­ã®ã¿å‡¦ç†
            const ext = path.extname(entry.name).toLowerCase();
            if (fileExtensions && !fileExtensions.includes(ext)) {
              continue;
            }

            // ãƒ•ã‚¡ã‚¤ãƒ«æƒ…å ±ã‚’åé›†
            try {
              const fileStat = await stat(fullPath);
              
              // å¤§ãã™ãã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã¯ã‚¹ã‚­ãƒƒãƒ—
              if (fileStat.size > MAX_FILE_SIZE) {
                continue;
              }

              // ãƒ•ã‚¡ã‚¤ãƒ«ã‚¿ã‚¤ãƒ—ã®çµ±è¨ˆã‚’æ›´æ–°
              repoInfo.fileTypes[ext] = (repoInfo.fileTypes[ext] || 0) + 1;
              
              // ãƒ•ã‚¡ã‚¤ãƒ«å†…å®¹ã‚’å–å¾—ï¼ˆå¿…è¦ã«å¿œã˜ã¦ï¼‰
              const content = await readFile(fullPath, 'utf8');
              const lineCount = content.split('\n').length;
              
              // ãƒ•ã‚¡ã‚¤ãƒ«æƒ…å ±ã‚’ä¿å­˜
              repoInfo.analyzedFiles.push({
                path: relativePath,
                extension: ext,
                size: fileStat.size,
                lineCount,
                content: content.slice(0, 1000) + (content.length > 1000 ? "..." : "")
              });
              
              // ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹é€ ã«è¿½åŠ 
              const dirName = path.dirname(relativePath);
              if (!repoInfo.directoryStructure[dirName]) {
                repoInfo.directoryStructure[dirName] = { type: "directory", children: [] };
              }
              repoInfo.directoryStructure[dirName].children.push({
                name: entry.name,
                type: "file",
                extension: ext
              });

              repoInfo.fileCount++;
            } catch (err) {
              console.error(`Error processing file ${fullPath}:`, err);
            }
          }
        }
      };

      // ãƒªãƒã‚¸ãƒˆãƒªå…¨ä½“ã‚’ã‚¹ã‚­ãƒ£ãƒ³
      await scanDirectory(repoPath);
      
      // ç°¡å˜ãªè¦ç´„æƒ…å ±ã‚’ç”Ÿæˆ
      repoInfo.summary = `Analyzed ${repoInfo.fileCount} files. Found ${Object.keys(repoInfo.fileTypes).length} different file types.`;
      
      return { 
        success: true, 
        repoInfo
      };
    } catch (error) {
      console.error("Failed to analyze repository:", error);
      return { 
        success: false, 
        error: String(error) 
      };
    }
  }
});
```

ã“ã®ã‚³ãƒ¼ãƒ‰ã‚’è¦‹ã¦ã€Œã†ã‚ãã€é•·ã„...ã€ã¨æ€ã£ãŸã‚ãªãŸã€å®Ÿã¯ã“ã®ã‚³ãƒ¼ãƒ‰ãŒè¡Œã£ã¦ã„ã‚‹ã“ã¨ã¯ã€ã€Œãƒªãƒã‚¸ãƒˆãƒªã®ä¸­ã‚’æ¢æ¤œã—ã¦ã€ç™ºè¦‹ã—ãŸãƒ•ã‚¡ã‚¤ãƒ«ã®ç‰¹å¾´ã‚’ãƒ¡ãƒ¢ã™ã‚‹ã€ã¨ã„ã†ã‚·ãƒ³ãƒ—ãƒ«ãªä»•äº‹ãªã‚“ã§ã™ï¼ã¾ã‚‹ã§æ£®ã®ä¸­ã‚’æ­©ã„ã¦æ¤ç‰©ã‚„å‹•ç‰©ã‚’è¨˜éŒ²ã—ã¦ã„ãè‡ªç„¶èª¿æŸ»å“¡ã®ã‚ˆã†ãªã‚‚ã®ã§ã™ã­ã€‚ã“ã®ãƒ„ãƒ¼ãƒ«ã®ãŠã‹ã’ã§ã€ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¯ã‚³ãƒ¼ãƒ‰ã®æ£®ã®åœ°å›³ã‚’æ‰‹ã«å…¥ã‚Œã‚‹ã“ã¨ãŒã§ãã¾ã™ï¼ğŸ—ºï¸

### Cursor Rulesç”Ÿæˆãƒ„ãƒ¼ãƒ«ã®ä½œæˆ âœï¸

ã•ã‚ã€ã„ã‚ˆã„ã‚ˆæœ€å¾Œã®é­”æ³•ã®é“å…·ã€ã€ŒCursor Rulesç”Ÿæˆãƒ„ãƒ¼ãƒ«ã€ã‚’ä½œæˆã—ã¾ã—ã‚‡ã†ï¼ã“ã®ãƒ„ãƒ¼ãƒ«ã¯ã€å‰ã®ã‚¹ãƒ†ãƒƒãƒ—ã§é›†ã‚ãŸæƒ…å ±ã‚’ã‚‚ã¨ã«ã€ç´ æ•µãªCursor Rulesã‚’è‡ªå‹•ã§ä½œã£ã¦ãã‚Œã‚‹èŠ¸è¡“å®¶ã®ã‚ˆã†ãªå­˜åœ¨ã§ã™ã€‚ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã‚’`src/mastra/tools/cursor-rules-generator.ts`ã¨ã—ã¦ä¿å­˜ã—ã¦ãã ã•ã„ã€‚

```typescript
import { createTool } from "@mastra/core/tools";
import fs from "fs";
import path from "path";
import { promisify } from "util";
import { z } from "zod";

const writeFile = promisify(fs.writeFile);
const mkdir = promisify(fs.mkdir);

// ãƒªãƒã‚¸ãƒˆãƒªæƒ…å ±ã‚¹ã‚­ãƒ¼ãƒã®ç°¡ç•¥åŒ–ãƒãƒ¼ã‚¸ãƒ§ãƒ³ï¼ˆå®Œå…¨ãªã‚¹ã‚­ãƒ¼ãƒã¯çœç•¥ï¼‰
const repoInfoSchema = z.object({
  name: z.string(),
  fileCount: z.number(),
  fileTypes: z.record(z.number()),
  directoryStructure: z.record(z.any()),
  analyzedFiles: z.array(z.any())
});

// å…¥åŠ›ã‚¹ã‚­ãƒ¼ãƒã®å®šç¾©
const inputSchema = z.object({
  repoInfo: repoInfoSchema.describe("Repository information from the repoAnalysisTool"),
  outputDir: z.string().optional().describe("Directory to save the generated .mdc file")
});

// å‡ºåŠ›ã‚¹ã‚­ãƒ¼ãƒã®å®šç¾©
const outputSchema = z.object({
  success: z.boolean(),
  outputPath: z.string().optional(),
  message: z.string().optional(),
  error: z.string().optional()
});

export const cursorRulesGeneratorTool = createTool({
  id: "cursorRulesGeneratorTool",
  description: "Generate Cursor Rules (.mdc file) based on repository analysis",
  inputSchema,
  outputSchema,
  execute: async ({ context }) => {
    const { repoInfo, outputDir = "./cursor_rules" } = context;
    
    try {
      // Cursor Rulesç”¨ã®ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ
      let mdcContent = `# ${repoInfo.name} Cursor Rules\n\n`;
      
      // ãƒªãƒã‚¸ãƒˆãƒªã®æ¦‚è¦ã‚»ã‚¯ã‚·ãƒ§ãƒ³
      mdcContent += `## Repository Overview\n\n`;
      mdcContent += `This repository contains ${repoInfo.fileCount} files. `;
      mdcContent += `The main file types are: ${Object.entries(repoInfo.fileTypes)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 5)
        .map(([ext, count]) => `${ext} (${count})`)
        .join(", ")}.\n\n`;
      
      // ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹é€ ã‚»ã‚¯ã‚·ãƒ§ãƒ³
      mdcContent += `## Directory Structure\n\n`;
      mdcContent += `\`\`\`\n`;
      
      // ç°¡ç•¥åŒ–ã•ã‚ŒãŸãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹é€ ã‚’æ§‹ç¯‰
      const buildDirTree = (dir = "", level = 0) => {
        const indent = "  ".repeat(level);
        let tree = "";
        
        // ãƒ«ãƒ¼ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®å ´åˆ
        if (dir === "") {
          tree += `${indent}${repoInfo.name}/\n`;
          
          // æœ€ä¸Šä½ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã¨ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å–å¾—
          const topLevelEntries = Object.keys(repoInfo.directoryStructure)
            .filter(path => !path.includes("/") || path.split("/").length === 1)
            .sort();
          
          for (const entry of topLevelEntries) {
            const structure = repoInfo.directoryStructure[entry];
            if (structure && structure.type === "directory") {
              tree += buildDirTree(entry, level + 1);
            }
          }
          
          return tree;
        }
        
        // é€šå¸¸ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®å ´åˆ
        tree += `${indent}${path.basename(dir)}/\n`;
        
        // ã“ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®å­è¦ç´ ã‚’è¡¨ç¤º
        const dirStructure = repoInfo.directoryStructure[dir];
        if (dirStructure && dirStructure.children) {
          const sortedChildren = [...dirStructure.children].sort((a, b) => {
            // ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’å…ˆã«è¡¨ç¤º
            if (a.type !== b.type) return a.type === "directory" ? -1 : 1;
            return a.name.localeCompare(b.name);
          });
          
          for (const child of sortedChildren) {
            if (child.type === "file") {
              tree += `${indent}  ${child.name}\n`;
            }
          }
        }
        
        return tree;
      };
      
      mdcContent += buildDirTree();
      mdcContent += `\`\`\`\n\n`;
      
      // ã‚³ãƒ¼ãƒ‰è¦ç´„ã¨ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚»ã‚¯ã‚·ãƒ§ãƒ³
      mdcContent += `## Code Conventions and Patterns\n\n`;
      mdcContent += `Based on the analysis of this repository, the following conventions and patterns are observed:\n\n`;
      
      // ãƒ•ã‚¡ã‚¤ãƒ«æ‹¡å¼µå­ã”ã¨ã®ä¸€èˆ¬çš„ãªè¦ç´„ï¼ˆä¾‹ï¼‰
      const extensionPatterns = {};
      
      Object.keys(repoInfo.fileTypes).forEach(ext => {
        switch (ext) {
          case ".ts":
          case ".tsx":
            extensionPatterns[ext] = "TypeScript files use interfaces for type definitions and follow functional programming patterns.";
            break;
          case ".js":
          case ".jsx":
            extensionPatterns[ext] = "JavaScript files use ES6+ features like arrow functions, destructuring, and template literals.";
            break;
          case ".py":
            extensionPatterns[ext] = "Python files follow PEP 8 style guide with docstrings for functions and classes.";
            break;
          // ä»–ã®æ‹¡å¼µå­ã‚‚åŒæ§˜ã«è¿½åŠ 
        }
      });
      
      // æ‹¡å¼µå­ã”ã¨ã®è¦ç´„ã‚’è¿½åŠ 
      Object.entries(extensionPatterns).forEach(([ext, pattern]) => {
        mdcContent += `- **${ext} files**: ${pattern}\n`;
      });
      
      mdcContent += `\n`;
      
      // åˆ†æã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã®ä¾‹ã‚»ã‚¯ã‚·ãƒ§ãƒ³
      mdcContent += `## Key Files and Their Purpose\n\n`;
      
      // é‡è¦ãã†ãªãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠï¼ˆå˜ç´”ãªä¾‹ã¨ã—ã¦ã€å„ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®æœ€åˆã®ãƒ•ã‚¡ã‚¤ãƒ«ï¼‰
      const keyFiles = new Set();
      
      Object.entries(repoInfo.directoryStructure).forEach(([dir, structure]) => {
        if (structure.children && structure.children.length > 0) {
          const files = structure.children.filter(child => child.type === "file");
          if (files.length > 0) {
            keyFiles.add(path.join(dir, files[0].name));
          }
        }
      });
      
      // åˆ†æå¯¾è±¡ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰å®Ÿéš›ã«å­˜åœ¨ã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æŠ½å‡º
      const analyzedKeyFiles = repoInfo.analyzedFiles
        .filter(file => keyFiles.has(file.path))
        .slice(0, 5);  // æœ€å¤§5ã¤ã¾ã§
      
      analyzedKeyFiles.forEach(file => {
        mdcContent += `### ${file.path}\n\n`;
        mdcContent += `**Purpose**: This file appears to ${file.path.includes("index") ? "be an entry point" : "contain implementation details"}.\n\n`;
        
        // ãƒ•ã‚¡ã‚¤ãƒ«ã®å†…å®¹ã®ä¸€éƒ¨ã‚’è¡¨ç¤º
        mdcContent += `**Preview**:\n\`\`\`${file.extension.replace(".", "")}\n${
          file.content.split("\n").slice(0, 10).join("\n")
        }\n...\n\`\`\`\n\n`;
      });
      
      // ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹
      mdcContent += `## Best Practices for This Codebase\n\n`;
      mdcContent += `When working with this repository, consider these best practices:\n\n`;
      mdcContent += `1. Follow the existing project structure for new files and features\n`;
      mdcContent += `2. Match the coding style and patterns used in similar files\n`;
      mdcContent += `3. Review the key files to understand the core architecture\n`;
      mdcContent += `4. Check for any project-specific documentation before making changes\n\n`;
      
      // å‡ºåŠ›ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ä½œæˆ
      await mkdir(outputDir, { recursive: true });
      
      // .mdcãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä¿å­˜
      const outputPath = path.join(outputDir, `${repoInfo.name}_cursor_rules.mdc`);
      await writeFile(outputPath, mdcContent);
      
      return { 
        success: true, 
        outputPath,
        message: `Successfully generated Cursor Rules at ${outputPath}`
      };
    } catch (error) {
      console.error("Failed to generate Cursor Rules:", error);
      return { 
        success: false, 
        error: String(error) 
      };
    }
  }
});
```

ã“ã®ã‚³ãƒ¼ãƒ‰ã¯ã¾ã‚‹ã§å°èª¬å®¶ã®ã‚ˆã†ã«ã€åé›†ã—ãŸæƒ…å ±ã‹ã‚‰ç¾ã—ã„ã‚¹ãƒˆãƒ¼ãƒªãƒ¼ï¼ˆCursor Rulesï¼‰ã‚’ç´¡ãå‡ºã—ã¾ã™ï¼ã€Œä½•ã“ã‚Œé›£ã—ãã†...ã€ã¨æ€ã†ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ãŒã€å®Ÿã¯ã“ã®ã‚³ãƒ¼ãƒ‰ãŒã‚„ã£ã¦ã„ã‚‹ã“ã¨ã¯ã€ã€Œé›†ã‚ãŸæƒ…å ±ã‚’æ•´ç†ã—ã¦ã€ãã‚Œã„ãªå½¢å¼ã§ãƒ•ã‚¡ã‚¤ãƒ«ã«æ›¸ãå‡ºã™ã€ã¨ã„ã†ã‚·ãƒ³ãƒ—ãƒ«ãªã“ã¨ãªã‚“ã§ã™ã€‚ã¾ã‚‹ã§ãƒ¬ãƒãƒ¼ãƒˆã‚’æ›¸ãã‚ˆã†ãªã‚‚ã®ã§ã™ã­ï¼ğŸ–‹ï¸

### ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®å®šç¾© ğŸ¤–

ã„ã‚ˆã„ã‚ˆæœ€å¾Œã®ã‚¹ãƒ†ãƒƒãƒ—ã€ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆæœ¬ä½“ã®å®šç¾©ã§ã™ã€‚ã“ã‚Œã¾ã§ä½œã£ã¦ããŸ3ã¤ã®é­”æ³•ã®é“å…·ã‚’çµ„ã¿åˆã‚ã›ã¦ã€ä¸€ã¤ã®å¼·åŠ›ãªã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’ç”Ÿã¿å‡ºã—ã¾ã™ï¼ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã‚’`src/mastra/agents/github-analyzer-agent.ts`ã¨ã—ã¦ä¿å­˜ã—ã¦ãã ã•ã„ã€‚ã“ã“ã¾ã§æ¥ãŸã‚ãªãŸã¯ã‚‚ã†ç†Ÿç·´ã®é­”æ³•ä½¿ã„ã§ã™ã­ï¼âœ¨

```typescript
import { Agent } from "@mastra/core/agent";
import { openai } from "@ai-sdk/openai";
import { githubCloneTool } from "../tools/github-clone-tool";
import { repoAnalysisTool } from "../tools/repo-analysis-tool";
import { cursorRulesGeneratorTool } from "../tools/cursor-rules-generator";

export const githubAnalyzerAgent = new Agent({
  name: "GitHub Analyzer Agent",
  instructions: `You are a GitHub repository analyzer that helps users understand codebases and generate Cursor Rules.

Your tasks:
1. When given a GitHub repository URL, clone it using the githubCloneTool
2. Analyze the repository structure and code using the repoAnalysisTool
3. Summarize the repository structure, key features, and coding patterns
4. Generate Cursor Rules in .mdc format using the cursorRulesGeneratorTool

For Cursor Rules creation:
- Focus on project-specific patterns, conventions, and best practices
- Include helpful context about the codebase's organization
- Format rules as markdown with clear descriptions
- Structure information in a way that helps other developers understand the codebase quickly

When analyzing the repository:
- Look for common design patterns and architecture
- Identify naming conventions and coding standards
- Note important dependencies and how they're used
- Understand the project's structure and organization

Be thorough but concise in your analysis. Ask clarifying questions if needed.`,
  model: openai("gpt-4o"),
  tools: { 
    githubCloneTool,
    repoAnalysisTool,
    cursorRulesGeneratorTool
  },
});
```

ãªã‚“ã¨ç°¡æ½”ãªã‚³ãƒ¼ãƒ‰ã§ã—ã‚‡ã†ï¼ã“ã‚ŒãŒç§ãŸã¡ã®ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®ã€Œè„³ã€ã¨ãªã‚‹éƒ¨åˆ†ã§ã™ã€‚ãŸã£ãŸæ•°è¡Œã®ã‚³ãƒ¼ãƒ‰ã§ã™ãŒã€ãã®ä¸­ã«ã¯å‰ã®ã‚¹ãƒ†ãƒƒãƒ—ã§ä½œæˆã—ãŸ3ã¤ã®å¼·åŠ›ãªãƒ„ãƒ¼ãƒ«ãŒçµ„ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã™ã€‚ã“ã®ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¯ã€ã¾ã‚‹ã§å„ªç§€ãªæ¢åµã®ã‚ˆã†ã«ã€GitHubãƒªãƒã‚¸ãƒˆãƒªã®ç§˜å¯†ã‚’è§£ãæ˜ã‹ã—ã€æœ‰ç”¨ãªCursor Rulesã‚’ç”Ÿæˆã—ã¦ãã‚Œã¾ã™ã€‚ç´ æ™´ã‚‰ã—ã„ã§ã™ã­ï¼ğŸ•µï¸â€â™€ï¸

## ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®å‹•ä½œç¢ºèª ğŸ®

ã“ã“ã¾ã§ãã‚Œã°ã€ã‚‚ã†æˆåŠŸã¯ç›®å‰ã§ã™ï¼Mastraã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®å®Ÿè£…ãŒå®Œäº†ã—ãŸã®ã§ã€å®Ÿéš›ã«é­”æ³•ãŒåƒãã¨ã“ã‚ã‚’è¦‹ã¦ã¿ã¾ã—ã‚‡ã†ã€‚ãƒ¯ã‚¯ãƒ¯ã‚¯ã—ã¾ã™ã­ï¼

### é–‹ç™ºã‚µãƒ¼ãƒãƒ¼ã®èµ·å‹• ğŸš€

ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã§ä»¥ä¸‹ã®ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œã—ã¦ã€é­”æ³•ã®ä¸–ç•Œã¸ã®æ‰‰ã‚’é–‹ãã¾ã—ã‚‡ã†ï¼š

```bash
npm run dev
```

ã“ã‚Œã§ã‚µãƒ¼ãƒãƒ¼ãŒèµ·å‹•ã—ãŸã‚‰ã€Mastraã®é–‹ç™ºç’°å¢ƒã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã™ã€‚ç°¡å˜ã§ã™ã­ï¼

### ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¨ã®å¯¾è©± ğŸ’¬

Mastraã®é–‹ç™ºç’°å¢ƒã§ã€ŒGitHub Analyzer Agentã€ã‚’é¸æŠã—ã€ä»¥ä¸‹ã®ã‚ˆã†ãªãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã§ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã«é­”æ³•ã‚’è¨—ã—ã¾ã—ã‚‡ã†ï¼š

```
Please analyze this GitHub repository: https://github.com/facebook/react
```

ãã—ã¦ã€é­”æ³•ãŒå§‹ã¾ã‚Šã¾ã™ï¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¯ãƒªãƒã‚¸ãƒˆãƒªã‚’ã‚¯ãƒ­ãƒ¼ãƒ³ã—ã€ã‚³ãƒ¼ãƒ‰ã‚’è§£æã—ã¦ã€ç¾ã—ã„Cursor Rulesã‚’ç”Ÿæˆã—ã¦ãã‚Œã¾ã™ã€‚ã¾ã‚‹ã§AIãŒå¥ã§ã‚‹äº¤éŸ¿æ›²ã®ã‚ˆã†ã§ã™ï¼ğŸµ

### ç”Ÿæˆã•ã‚ŒãŸCursor Rulesã®ç¢ºèª ğŸ“

ç”Ÿæˆã•ã‚ŒãŸCursor Rulesã‚’ãƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒ‡ã‚£ã‚¿ã§é–‹ãã€ãã®å†…å®¹ã‚’ã˜ã£ãã‚Šçœºã‚ã¦ã¿ã¾ã—ã‚‡ã†ã€‚ã‚ãªãŸãŒå‘½ã‚’å¹ãè¾¼ã‚“ã ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒå‰µã‚Šå‡ºã—ãŸèŠ¸è¡“ä½œå“ã§ã™ï¼ã“ã‚Œã‚’Cursorã‚¢ãƒ—ãƒªã«ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹ã“ã¨ã§ã€AIãŒãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã«é–¢ã™ã‚‹è©³ã—ã„çŸ¥è­˜ã‚’æŒã¡ã€ã‚ãªãŸã®ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’ã‚ˆã‚Šã‚¹ãƒãƒ¼ãƒˆã«ã‚µãƒãƒ¼ãƒˆã—ã¦ãã‚Œã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚ç´ æ™´ã‚‰ã—ã„æˆæœã§ã™ã­ï¼ğŸ†

## ã¾ã¨ã‚ ğŸŒŸ

ãŠã‚ã§ã¨ã†ã”ã–ã„ã¾ã™ï¼ã“ã®ç« ã§ã¯ã€Mastraã‚’ä½¿ã£ãŸGitHubè§£æã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®é–‹ç™ºã‚’é€šã—ã¦ã€å®Ÿç”¨çš„ãªã‚¹ã‚­ãƒ«ã‚’èº«ã«ã¤ã‘ã¾ã—ãŸã€‚æœ€åˆã¯é›£ã—ãã†ã«è¦‹ãˆãŸã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ãŒã€ä¸€æ­©ãšã¤é€²ã‚ã‚‹ã“ã¨ã§ã€ã‚ãªãŸã‚‚ç«‹æ´¾ãªMastraã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆé–‹ç™ºè€…ã«ãªã‚Šã¾ã—ãŸã­ï¼

ã“ã®å†’é™ºã‚’é€šã˜ã¦ã€ãƒ„ãƒ¼ãƒ«ã®ä½œæˆã€ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®å®šç¾©ã€ãã—ã¦å®Ÿéš›ã®å‹•ä½œç¢ºèªã¾ã§ã€ã™ã¹ã¦ã®ãƒ—ãƒ­ã‚»ã‚¹ã‚’ä½“é¨“ã™ã‚‹ã“ã¨ãŒã§ãã¾ã—ãŸã€‚ã“ã‚Œã‹ã‚‰ã‚‚ã€ã“ã®çŸ¥è­˜ã‚’æ´»ã‹ã—ã¦ã€ã‚ãªãŸã ã‘ã®ç´ æ™´ã‚‰ã—ã„ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’ç”Ÿã¿å‡ºã—ã¦ã„ã£ã¦ãã ã•ã„ã€‚

æ¬¡ã®ç« ã§ã¯ã€ã•ã‚‰ã«é«˜åº¦ãªãƒ†ã‚¯ãƒ‹ãƒƒã‚¯ã‚’å­¦ã‚“ã§ã„ãã¾ã™ã€‚Mastraã®ä¸–ç•Œã¯ã¾ã ã¾ã åºƒãã€æ¢æ¤œã™ã¹ãå ´æ‰€ãŒãŸãã•ã‚“ã‚ã‚Šã¾ã™ã€‚å¼•ãç¶šãã€ä¸€ç·’ã«æ¥½ã—ã„å†’é™ºã‚’ç¶šã‘ã¦ã„ãã¾ã—ã‚‡ã†ï¼ğŸš€ 